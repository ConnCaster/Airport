[//]: # (### Запуск сервиса)
[//]: # (1. Разместить машинки на карте)
[//]: # (```)
[//]: # (POST /v1/vehicles/init)
[//]: # (```)

2. Самолет (Board) присылает в GroundControl запрос разрешения на посадку
(в текущее время, которое есть на самолете и у табло)
```
GET /v1/land_permission?flightId=flightId
```
3. GroundControl спрашивает у Табло (Information Panel) - ожидаем ли мы этот рейс.
```
GET /v1/flights/flightId=flightId
```
Information Panel проверяет по своему хранилищу рейсов - есть ли такой рейс 
в текущее или прошедшее время должен был приземлиться - подтверждает, что ожидаем.
Если нет - не подтверждает(возможно код 200, но с текстовым статусом отказа). 

И Самолет по собственным часам через 30 секунд повторно 
отправляет в GroundControl запрос разрешения на посадку(п.3)

4. В GroundControl 
Если посадка разрешена, то логика движется дальше:
- проверяем, что точка RE-1 на карте свободна 
(в ней не находится приземлившийся ранее самолет в ожидании машинки FollowMe, которая отвезет его на парковку)
Если нет, то отказываем в посадке, и отправляем на Табло (Information Panel) информацию о том,
что самолет задерживается
```
POST /v1/flights/
{
"flightId": "flightId",
"status": "Delayed"
}
```
- ищем свободную парковку на карте 
(карту передаем сервису GroundControl - после своего запуска читает из файла).
Если нет, то отказываем в посадке, и отправляем на Табло (Information Panel) информацию о том,
что самолет задерживается
```
POST /v1/flights/
{
    "flightId": "flightId",
    "status": "Delayed"
}
```
  - проверяем, есть ли свободные машинки в сервисе FollowMe
```
GET /v1/vehicles/hasEmpty
```
Если нет, то отказываем в посадке, и отправляем на Табло (Information Panel) информацию о том, 
что самолет задерживается
```
POST /v1/flights/
{
    "flightId": "flightId",
    "status": "Delayed"
}
```

После этого через 30 секунд самолет, как известно, запросит посадку заново у GroundControl,
и мы должны будем повторить все операции по описанному алгоритму.
Если машинка свободная была, то переводим ее в статус зарезервирована в ожидании посадки:
```
POST /v1/vehicles/
{
    "vehicleId": "vehicleId",
    "flightId": "flightId",
    "status": "ReservedForLandingPlane"
}
```
Такие машинки нельзя будет назначать на другие самолеты, пока она не отвезет до места стоянки свой приземлившийся самолет. 

Если посадка была разрешена, свободна точка RE-1, есть свободное место на парковке и есть свободные машинки - разрешаем посадку.

Если посадка разрешена, то самолет оказывается в точке RE-1. 
Точка после посадки в нее самолета должна быть помечена, как занятая, чтобы в нее не приземлился еше какой-нибудь самолет.

## Промежуточный вопрос:
Все движения по карте после посадки самолета будет отрисовывать отдельный сервис AirportVisualizer. Я абсолютно не в курсе,
как и с помощью каких технологий это происходит. А самое плохое, я не знаю, что и как я должен отправлять на этот сервис отвечать на его запросы,
чтобы правильно в лучших best-practice построить архитектуру взаимодействия сервисов. Я знаю точно, что при запуске сервисов, визуалайзер
будет запускаться последним и уже сможет обладать информацией о начальном положении машинок на карте (в моем случае на карте это FS-1).
При этом общаться так или иначе он может только с GroundControl. Помоги спроектировать API, чтобы оно соответствовало требованиям хорошей архитектуры для будущего визуализирования.
Разработчик визуализатора - отказывается взаимодействовать с командой, поэтому приходится проектировать все без него. Но реализовывать логику его сервиса не нужно,
он сделает сам.
Кроме того, подумай, как GroundControl будет узнавать о положении машинок в разный момент времени, чтобы каким-то образом общаться на эту тему с AirportVisualizer.
Важно учесть, что машинки в движении могут останавливаться и ждать, когда освободится узел или ребро (ждать можно и в узле и в ребре).
Может для отслеживания положения машинок и передачи каким то способом визуализатору будет достаточно карты, где мы будем знать, кто занимает какую точку или ребро? Просто как идея.

Идем дальше. 
5. Когда машинка в сервисе FollowMe зарезервировалась для своего самолета, она должна спросить у GroundControl - маршрут движения вместе с самолетом.
То есть на какую парковку доставить самолет после посадки. 
```
GET /v1/map/followme/path/flightId=flightId
```
В ответ получаем точку отправления и точку парковки.
```
{
    "from": "RE-1",
    "to": "P1"
}
```
На обратном пути машинка должна будет вернуться в точку RE-1, а оттуда проследовать в FS-1 для стоянки.
6. Далее сервис FollowMe должен опрашивать сервис GroundControl для разрешения на отправку к точке посадки самолета, чтобы начать с ним движение к стоянке.
```
GET /v1/map/followme/permission/flightId=flightId
```
Если разрешение не поступает, а оно поступит только в том случае, если самолет уже в точке FS-1, то запрашивать до тех пор через таймаут в 5 секунд, пока разрешение не дадут.
Если поступило, то выезжает, предварительно сменив статус на moveToLandingPosition.
7. Если разрешение поступило, то FollowMe должна транслировать на GroundControl свое положение, чтобы тот помечал на карте, где она находится.
Для этого
```
POST /v1/map/followme/path/
{
    "vehicleId": "vehicleId",
    "flightId": "flightId",
    "currentPosition": "EP-38". 
}
```
## Промежуточный вопрос:
Может трансляция положения и не нужна, но как тогда сделать так, чтобы GroundControl в любой момент знал, где находится каждая машинка на карте?
А также как организовать проверку следующего участка маршрута каждой машинкой, чтобы она могла постоять и подождать, если необходимо в текущем положении, 
пока следующее ребро или узел не освободятся. Помоги для этого придумать архитектуру в сервисах и по необходимости дополнительные API там, где это нужно.

8. Когда прибыват машинка в парковочную точку, FollowMe сообщает GroundControl о том, что достигнута парковка
```aiignore
POST /v1/vehicles/followme/
{
    "vehicleId": "vehicleId",
    "flightId": "flightId",
    "status": "arrivedParking". 
}
```
После этого машинка отправляется на парковку машинок FollowMe FS-1. 
Когда парковка достигнута, статус машинки в FollowMe переводится в empty, чтобы GroundControl смог зарезарвировать ее для следующего рейса.
